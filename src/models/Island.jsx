/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Skylar Muffin (https://sketchfab.com/boopdesignstudio)
License: CC-BY-NC-4.0 (http://creativecommons.org/licenses/by-nc/4.0/)
Source: https://sketchfab.com/3d-models/stylized-3d-floating-island-and-mine-house-3cb24182a8504d439ee4e3c500565ac5
Title: Stylized 3D Floating Island And Mine House
*/

import React, { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
//import islandScene from '../assets/stylized_3d_floating_island_and_mine_house.glb'
import islandScene from '../assets/3d/island.glb'
import {a} from '@react-spring/three'
//import { is } from '@react-three/fiber/dist/declarations/src/core/utils'

//enlever cast et receivce shdaow?

const Island = ({isRotating, setIsRotating, islandPosition, islandScale, rotation, setCurrentStage, ...props}) => {
  const islandRef = useRef()
  const { gl, viewport } = useThree()
  const { nodes, materials } = useGLTF(islandScene)
  const lastX = useRef(0)
  const rotationSpeed = useRef(0)
  const dampingFactor = 0.95

  const handlePointerDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true)

    const clientX = e.touches ? e.touches[0].clientX : e.clientX

    lastX.current = clientX
  }
  const handlePointerUp = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(false)


  }
  const handlePointerMove = (e) => {
    e.stopPropagation();
    e.preventDefault();

    if(isRotating){
      const clientX = e.touches ? e.touches[0].clientX : e.clientX

    const delta = (clientX - lastX.current) / viewport.width

    islandRef.current.rotation.y += delta * Math.PI * 0.01

    lastX.current = clientX

    rotationSpeed.current = delta * Math.PI * 0.01
    }
  }

  const arrowDirection = useRef(null);

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowLeft') {
      setIsRotating(true);
      arrowDirection.current = 'left';
    } else if (e.key === 'ArrowRight') {
      setIsRotating(true);
      arrowDirection.current = 'right';
    }
  };
  
  const handleKeyUp = (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
      setIsRotating(false);
      arrowDirection.current = null;
    }
  };



  useFrame(() => {
    if (!isRotating) {
      rotationSpeed.current *= dampingFactor;
      islandRef.current.rotation.y += rotationSpeed.current;
    } else {
      const speed = 0.01;
      if (arrowDirection.current === 'left') {
        islandRef.current.rotation.y += speed;
      } else if (arrowDirection.current === 'right') {
        islandRef.current.rotation.y -= speed;
      }
    }
  
    const currentY = islandRef.current.rotation.y;
    const normalizedRotation = ((currentY % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
  
    switch (true) {
      case normalizedRotation >= 5.7 && normalizedRotation <= 6.3:
        setCurrentStage(4);
        break;
      case normalizedRotation >= 0.38 && normalizedRotation <= 0.92:
        setCurrentStage(3);
        break;
      case normalizedRotation >= 2.68 && normalizedRotation <= 3.7:
        setCurrentStage(2);
        break;
      case normalizedRotation >= 4.43 && normalizedRotation <= 5.06:
        setCurrentStage(1);
        break;
      default:
        setCurrentStage(null);
    }
  });

  useEffect(() => {
    const canvas = gl.domElement
    canvas.addEventListener('pointerdown', handlePointerDown)
    canvas.addEventListener('pointerup', handlePointerUp)
    canvas.addEventListener('pointermove', handlePointerMove)
    document.addEventListener('keyup', handleKeyUp)
    document.addEventListener('keydown', handleKeyDown)
  

    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown)
      canvas.removeEventListener('pointerup', handlePointerUp)
      canvas.removeEventListener('pointermove', handlePointerMove)
      document.removeEventListener('keyup', handleKeyUp)
      document.removeEventListener('keydown', handleKeyDown)
    }
   }, [gl, handlePointerDown, handlePointerUp, handlePointerMove])
    

  return (
    <a.group ref ={islandRef} {...props}>
      <group rotation= {rotation} position={islandPosition} scale={islandScale}>
        <group>
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_Bridge_Mat001_0.geometry}
            material={materials['SF_Bridge_Mat.001']}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Roof_Final_0.geometry}
            material={materials.SF_Roof_Final}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Roof_Final_0_1.geometry}
            material={materials.SF_Roof_Final}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Roof_Final_0_2.geometry}
            material={materials.SF_Roof_Final}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Roof_Final_0_3.geometry}
            material={materials.SF_Roof_Final}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Rocks_Mat_0.geometry}
            material={materials.SF_Rocks_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Windows_Mat_0.geometry}
            material={materials.SF_Windows_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Windows_Mat_0_1.geometry}
            material={materials.SF_Windows_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Windows_Mat_0_2.geometry}
            material={materials.SF_Windows_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Bush_Mat_0.geometry}
            material={materials.SF_Bush_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_TreeWood_Mat_0.geometry}
            material={materials.SF_TreeWood_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_TreeWood_Mat_0_1.geometry}
            material={materials.SF_TreeWood_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_TreeLeaf_Mat_0.geometry}
            material={materials.SF_TreeLeaf_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_HouseSupport_Mat_0.geometry}
            material={materials.SF_HouseSupport_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_HouseJoins_Mat_0.geometry}
            material={materials.SF_HouseJoins_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Chimney_Mat_0.geometry}
            material={materials.SF_Chimney_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_CutRock_Mat_0.geometry}
            material={materials.SF_CutRock_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Stalagmites_Mat_0.geometry}
            material={materials.SF_Stalagmites_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_WoodTex_Mat_0.geometry}
            material={materials.SF_WoodTex_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_PlasterTex_Mat_0.geometry}
            material={materials.SF_PlasterTex_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_StoneBrick_Mat_0.geometry}
            material={materials.SF_StoneBrick_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Island_Mat_0.geometry}
            material={materials.SF_Island_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_LampGlass_Mat_0.geometry}
            material={materials.SF_LampGlass_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Lamp_Mat_0.geometry}
            material={materials.SF_Lamp_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Candle_Mat_0.geometry}
            material={materials.SF_Candle_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Grass_Mat_0.geometry}
            material={materials.SF_Grass_Mat}
          />
          <mesh
             castShadow
             receiveShadow
            
            geometry={nodes.Final_Bridge1_SF_Rail_Mat_0.geometry}
            material={materials.SF_Rail_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_GrassCards_Mat_0.geometry}
            material={materials.SF_GrassCards_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_GrassCards_Mat_0_1.geometry}
            material={materials.SF_GrassCards_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_GrassCards_Mat_0_2.geometry}
            material={materials.SF_GrassCards_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_GrassCards_Mat_0_3.geometry}
            material={materials.SF_GrassCards_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_Sack_Mat_0.geometry}
            material={materials.SF_Sack_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_MineCart_Mat_0.geometry}
            material={materials.SF_MineCart_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_Bridge_Mat_0.geometry}
            material={materials.SF_Bridge_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_Door_Mat_0.geometry}
            material={materials.SF_Door_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_Water_Mat_0.geometry}
            material={materials.SF_Water_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_Final_Water001_0.geometry}
            material={materials['Final_Water.001']}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_Final_Rocks2_Mat_0.geometry}
            material={materials.Final_Rocks2_Mat}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_Black_0.geometry}
            material={materials.Black}
          />
          <mesh
           castShadow
           receiveShadow
            geometry={nodes.Final_Bridge1_SF_ButterFly_Mat_0.geometry}
            material={materials.SF_ButterFly_Mat}
          />
          <mesh
           castShadow
            receiveShadow

            geometry={nodes.Final_Bridge1_SF_Lillypad_Mat_0.geometry}
            material={materials.SF_Lillypad_Mat}
          />
          </group>
        </group>
    </a.group>
  )
}


export default Island



